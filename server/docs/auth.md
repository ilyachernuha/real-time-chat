# INTRODUCTION

Whisper supports 2 types of user accounts: registered users and guests.

Both types of accounts have the following attributes:
- `user_id` (unique and persistent identifier generated by server)
- `name` (non-unique editable name shown in chats)

While registered users also have additional attributes:
- `username` (unique changeable identifier used for user invitations etc)
- `email` (unique, changeable)
- `password` (stored as hash)

# SESSIONS

Every time a client successfully logs in the server creates a new session that is linked to the user account. Apart from that each session has a unique id and contains information about the device, latest activity (defined by the latest token update) and current refresh token.

Registered users can have multiple sessions associated with their accounts while guests can have only one session.
# TOKENS

Whisper uses a combination of stateless access token and stateful refresh token. Access token is a JWT with expiration time of 15 minutes that contains `user_id` and `session_id`. Refresh token is generated randomly be the server and stored as hash. Each time a new access token is generated, refresh token is rotated.

To update access token client sends `POST` request to `"/token_refresh"` with JSON body that contains:

```
{
    "refresh_token": "vnJkffMnp0bo4UaaBU3g372VwAd3II5BeJo3BP9Od6t4ox2zhQjzw0b4-_l76pQ2g_2z1FpFXodneU4DB9mlkA"`
}
```

Server responds with a new token pair:

```
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiZTZmYzdjZDYtOGQ5My00OWY4LWFmOWQtNWFiZjA0OTE1MTRiIiwic2Vzc2lvbl9pZCI6IjM2ODhjZTM4LWIyYjMtNDBjNS05NzQyLTA4OTNhOGE5OTE0MCIsImV4cCI6MTcwOTMzODAyMH0.eY4dXH7tG53mU7YP2m2dfGV0a-bcSkWYY5B7L7Oj2Bw",
    "new_refresh_token": "PYMYaTNzbY86JrWchg-dfvWFaBSthYzXi7uw2lW24Z2fqBAwwCSh4CSHmZ5920w5-O53tPyeGYwUxGg_AIHK_g"
}
```

Previously generated access token will remain valid until it expires even if a new was generated. After refresh token was rotated its previous versions will no longer be valid.

# CREATING ACCOUNT

The process of creating account involves a few steps:
## 1. Initial client request

Client sends `POST` request to `"/create_account"` with the following JSON body structure:

```
{
    "username": "user1",
    "email": "user1@example.com",
    "password": "asdfasdf",
    "device_info": "test"
}
```

`"device_info"` attribute is optional and has a default value `"Unknown"`

## 2. Creation of register application

Server checks if username and email are available and creates a register application that includes unique id, data submitted in a request, timestamp, confirmation code and status (used internally by the server).

Status can have the following values:
- `pending` (assigned at creation)
- `confirmed` (assigned when user successfully confirms email)
- `confirmed_elsewhere` (assigned if a another application with the same email was confirmed)
- `failed` (assigned after 3 failed confirmation attempts)
- `expired` (assigned after 15 minutes since creation if status is pending)

Server sends application id in a response to client's request and a confirmation code to the specified email.
Here's an example of server response:

```
{
    "status": "Email confirmation required",
    "application_id": "d7d766df-72f6-4de1-9fd0-c8afca6daff7"
}
```

**Note:** Register confirmations are stored separately from users. All data in a register application is non-unique except id. This allows several applications to have the same email or username.

## 3. Email confirmation

Client sends a `POST` request to `"/finish_registration"` with the following JSON body structure:

```
{
    "application_id": "d7d766df-72f6-4de1-9fd0-c8afca6daff7",
    "confirmation_code": "1234"
}
```

**Note:** Each application has its own confirmation code. If there are several concurrent applications with the same email, client must provide application id and confirmation code that match. This ensures users cannot accidentally confirm applications they haven't sent. To help users identify the correct confirmation code, `"device_info"` from initial client request is included in the confirmation email.

## 4. Creation of user account

Server does a few checks here:
- application status is `pending`
- application id and confirmation code match
- username and email are still available

If all checks are passed, it makes application status `confirmed` and the status of other applications with the same email `confirmed_elsewhere`, creates user account and session.

Here's an example of server response:

```
{
    "user_id": "e6fc7cd6-8d93-49f8-af9d-5abf0491514b",
    "session_id": "60dbfe54-4473-462f-8536-a7ac18b957c7",
    "refresh_token": "85h1EBlz9yOnpM43EvicVWidmfFtJO1viUx6qQsYgC-sN79fecXS35pAOK6qcj0GoUY3QihOqVEpkumHHiqiQw",
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiZTZmYzdjZDYtOGQ5My00OWY4LWFmOWQtNWFiZjA0OTE1MTRiIiwic2Vzc2lvbl9pZCI6IjYwZGJmZTU0LTQ0NzMtNDYyZi04NTM2LWE3YWMxOGI5NTdjNyIsImV4cCI6MTcwOTMzNzQ5M30.0iGH7m_WAWdWqZbGOI2a7p07wPU2FxPxBmG76f6jGZI"
}
```

The `name` attribute of created user is same as `username` but it can be changed later (see CHANGING NAME).

# LOGGING IN TO EXISTING ACCOUNT

Logging in to existing account requires sending a `POST` request to `"/login"` that includes HTTP Basic Authorization header and optionally a JSON body that contains:

```
{
    "device_info": "test"
}
```

`"device_info"` is used by the server for session creation. If request contains no body or the body is an empty JSON default value `"Unknown"` will be used.

Client can submit both username + password and email + password as credentials.

Here's an example of server response:


```
{
    "user_id": "e6fc7cd6-8d93-49f8-af9d-5abf0491514b",
    "session_id": "3688ce38-b2b3-40c5-9742-0893a8a99140",
    "refresh_token": "vnJkffMnp0bo4UaaBU3g372VwAd3II5BeJo3BP9Od6t4ox2zhQjzw0b4-_l76pQ2g_2z1FpFXodneU4DB9mlkA",
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiZTZmYzdjZDYtOGQ5My00OWY4LWFmOWQtNWFiZjA0OTE1MTRiIiwic2Vzc2lvbl9pZCI6IjM2ODhjZTM4LWIyYjMtNDBjNS05NzQyLTA4OTNhOGE5OTE0MCIsImV4cCI6MTcwOTMzNzU1Nn0.g7fqDJzGB7oHtx6RWBDzQiy4UdU8bjGPVoVUa4URCe0"
}
```

# LOGGING IN AS GUEST

Logging in as guest requires sending a `POST` request to `"/guest_login"` with the following JSON body structure:

```
{
    "name": "guest1",
    "device_info": "test"
}
```

`"device_info"` attribute is optional and has a default value `"Unknown"`.

Here's an example of server response:

```
{
    "user_id": "fbf9918d-6889-4909-a6ae-1eb7f4123372",
    "session_id": "e3109003-66a3-420c-aece-bee85da27f8d",
    "refresh_token": "LRbNwos_PgpzpHxS6JOyoX-AwLdIi_M9r7tp5kZWIuQclo6ojR60Q3URMA7amSqH43qZFMwFseUe9BzhB9sy2w",
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiZmJmOTkxOGQtNjg4OS00OTA5LWE2YWUtMWViN2Y0MTIzMzcyIiwic2Vzc2lvbl9pZCI6ImUzMTA5MDAzLTY2YTMtNDIwYy1hZWNlLWJlZTg1ZGEyN2Y4ZCIsImV4cCI6MTcwOTMzNzU5OH0.ZgbtGaaez75BvUO2KCSZ7BI7IECornnZuEG9AJGCUp8"
}
```

# RESETTING PASSWORD

Registered users can reset their password. This process can be broken down into a few steps:

## 1. Initial client request

Client send `POST` request to `"/reset_password"`  with the following JSON body structure:

```
{
    "email": "user1@example.com"
}
```

## 2. Creation of reset password application

Server checks if an account with specified email exists, then creates a reset password application. Reset password applications have unique id and contain user id, timestamp and status that can be `pending`, `used` or `expired`. Reset password applications expire automatically in 15 minutes. Single user can have multiple reset password application but each application can be used but one application can be used only once.

Server sends an email to the specified address that contains reset password link that looks like this: `base_url/reset_password_page/{application_id}`.

Response to client's initial request is generic and doesn't contains any important data:

```
{
    "status": "email sent"
}
```

## 3. Submitting new password

User opens reset password link provided in the email and gets an HTML page that allows user to submit a new password.

To submit new password client sends `POST` request to `"/finish_reset_password"` with the following JSON body structure:

```
{
    "application_id": "407a55d8-c354-4271-99db-b95ef8748bd6",
    "new_password": "qwerty123"
}
```

**Note:** HTML page is not strictly necessary. Reset password link can be opened in application (preferred way), also it is possible to extract application id from the link and send `POST` request to `"/finish_reset_password"` manually (using any API testing tool).

## 4. Final validation

Server checks if application is not already used or expired and if so updated user's password. It sends a generic response that contains:

```
{
    "status": "success"
}
```

All sessions associated with the user account will be closed.

## 5. Logging in

After successful password reset client will have to log in (see LOGGING IN TO EXISTING ACCOUNT). If reset password link was opened within the same client that sent initial `"/reset_password"` request it should be able to log in automatically (depends of front end implementation).

# CHANGING USER CREDENTIALS

Updating user credential (username and password) requires users to submit their password.

Client has to include HTTP Basic Authorization header with either username + password or email + password as credentials.

There are 2 separate endpoints for changing username and password:

To update username client sends `PUT` request to `"/change_username"` with HTTP Basic Authorization header and the following JSON body structure:

```
{
    "new_username": "qwerty"
}
```

Here's an example of server response:

```
{
    "status": "success",
    "new_username": "qwerty"
}
```

To update password client sends `PUT` request to `"/change_password"` with HTTP Basic Authorization header and the following JSON body structure:

```
{
    "new_password": "qwerty123",
    "session_id": "78efff87-c8c4-4836-80db-39660b4809dd"
}
```

`session_id` is used to identify the current session. Server will close all other sessions.

Here's an example of server response:

```
{
    "status": "success"
}
```
# CHANGING EMAIL

Changing email is more complex as it requires users to confirm new email. Similarly to changing credentials users have to submit their password first. The process of changing email requires a few steps:

## 1. Initial client request

Client sends `POST` request to `"/change_email"` with HTTP Basic Authorization header and the following JSON body structure:

```
{
    "new_email": "new_email@example.com"
}
```

## 2. Creation of change email application

Server validates user credentials, checks if new email is available and creates change email application that includes unique id, user id, new email, old email, timestamp, confirmation code, status and rollback status (used internally by the server).

Status can have the following values:
- `pending` (assigned at creation)
- `confirmed` (assigned when user successfully confirms new email)
- `failed` (assigned after 3 failed confirmation attempts)
- `expired` (assigned after 15 minutes since creation if status is pending)
- `rolled_back` (assigned if user rolled back email)

For more information about email rollback see ROLLING BACK EMAIL.

Server sends application id in a response to client's request and a confirmation code to the specified email.
Here's an example of server response:

```
{
    "status": "Email confirmation required",
    "application_id": "1f0f4cf8-7ce1-499f-af9b-f21e50c14d5f"
}
```

**Note:** each user can have multiple change email applications.

## 3. Email confirmation

Client sends a `POST` request to `"/finish_change_email"` with the following JSON body structure:

```
{
    "application_id": "1f0f4cf8-7ce1-499f-af9b-f21e50c14d5f",
    "confirmation_code": "1234"
}
```

Similarly for register applications confirmation code has to match specific application.

## 4. Updating user email

Server checks if:
- application status is `pending`
- application id and confirmation code match
- specified email is still available

If all checks are passed, it makes application status `confirmed`, rollback status `pending` and updates user email.

# ROLLING BACK EMAIL

Email rollback is a security feature that allows users to revert email change.

Each change email application has rollback status which is different from status. It can hold the following values:
- `unavailable` (assigned at creation of application)
- `pending` (assigned at when application is confirmed)
- `completed` (assigned if email is successfully rolled back)
- `expired` (assigned after 72 hours since creation if rollback status is pending)

When email is changed the server will send an email to the previous address, notifying user about the change and providing a rollback link. Rollback link looks like this: `base_url/rollback_email_change/{application_id}`.

When user opens the link, server will revert email change, set change email applications status to `rolled_back` and rollback status to `completed`.

**Note:** server reserves old email addresses while rollback is possible (rollback status is `pending`). This is necessary to avoid situations when user tries to rollback email but it is already used by another account (emails must be unique).

# CHANGING NAME

Changing name is available for both registered users and guests. It requires including access token in HTTP Bearer Authorization header.

To change name client sends `PUT` request to `"/change_name"` with HTTP Bearer Authorization header and the following JSON body structure:

```
{
    "new_name": "qwerty"
}
```

Here's an example of server response:

```
{
    "status": "success",
    "new_name": "qwerty"
}
```

# SESSION MANAGEMENT

Session management includes 2 main operations: getting all currently active sessions and closing sessions.

## 1. Getting active sessions

To get the list of current sessions client sends `GET` request to `"/active_sessions"` that includes HTTP Bearer Authorization header with access token.

Here's an example of server response:

```
{
    "sessions": [
        {
            "session_id": "60dbfe54-4473-462f-8536-a7ac18b957c7",
            "device_info": "test",
            "latest_activity": "2024-03-01T23:43:13.473090+00:00"
        },
        {
            "session_id": "3688ce38-b2b3-40c5-9742-0893a8a99140",
            "device_info": "test",
            "latest_activity": "2024-03-01T23:52:00.567339+00:00"
        },
        {
            "session_id": "61bd9e76-b6a7-4017-b944-4e7e01220a8b",
            "device_info": "Unknown",
            "latest_activity": "2024-03-02T14:21:15.059552+00:00"
        }
    ]
}
```

**Note:** `latest_activity` is defined by the latest token refresh and is not real-time.

## 2. Closing Sessions

To close a session client sends POST request to "/close_session" that includes HTTP Bearer Authorization header with access token and the following JSON body structure:

```
{
    "session_id": "60dbfe54-4473-462f-8536-a7ac18b957c7"
}
```

Here's an example of server response:

```
{
    "status": "success"
}
```

**Note:** because access tokens are stateless, they will be valid until expired when session is closed. Refresh token of the closes session will become invalid immediately.